
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Vodka&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Vodka">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Vodka's Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Vodka's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vodka's Blog">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="Vodka&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Vodka&#39;s Blog" title="Vodka&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Vodka&#39;s Blog">Vodka&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/18/Javascript基础/" title="Javascript基础" itemprop="url">Javascript基础</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://yoursite.com/about" title="Vodka" target="_blank" itemprop="author">Vodka</a>
		
  <p class="article-time">
    <time datetime="2016-05-18T05:02:18.000Z" itemprop="datePublished"> 发表于 2016-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="JavaScript介绍、实现、输出">JavaScript介绍、实现、输出</h4><h6 id="介绍">介绍</h6><ol>
<li>JavaScript是互联网上最流行的脚本语言，这门语言可用于web和HTML，更可广泛用于服务器、pc端、移动端。</li>
<li>JavaScript脚本语言：<br> JavaScript是一种轻量级的编程语言<br> JavaScript是可插入HTML页面的编程代码<br> JavaScript插入HTML页面后，可有所有的浏览器执行</li>
</ol>
<h6 id="实现">实现</h6><ol>
<li>JavaScript用法：<br> HTML中的脚本必须位于<script></script>标签之间<br> 脚本可被放置HTML页面的<body>和<head>部分中</head></body></li>
<li>JavaScript标签：<br> 在HTML中插入JavaScript，使用<script>标签<br> 在<script></script>之间书写代码</li>
<li>JavaScript使用限制：<br> 在HTML中，不限制脚本熟料<br> 通常会把脚本放置于<head>标签中，以不干扰页面内容</head></li>
</ol>
<h4 id="JavaScript数据类型">JavaScript数据类型</h4><ol>
<li>字符串（String）</li>
<li>数字（Number）</li>
<li>布尔（Boolean）</li>
<li>数组（Array）</li>
<li>对象（Object）</li>
<li>空（null）</li>
<li>未定义</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/JS介绍、实现、输出/">JS介绍、实现、输出</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/21/swift初体验（一）/" title="swift初体验（一）" itemprop="url">swift初体验（一）</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://yoursite.com/about" title="Vodka" target="_blank" itemprop="author">Vodka</a>
		
  <p class="article-time">
    <time datetime="2015-06-21T14:54:13.000Z" itemprop="datePublished"> 发表于 2015-06-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="常量和变量">常量和变量</h3><ol>
<li><p>在swift中我们用<code>let</code>来定义一个常量，如果我们在下面在对a进行赋值的话编译器会给我们报错的</p>
 <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a =</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们用<code>var</code>来定义一个变量，在swift编译器会自动辨别你所定义的类型，如果我们要显示的定义一个类型，我们可以在变量后面加个<code>:类型</code>，在swift没有进行初始化的值是不能被直接使用的，因为其不会指派一个默认值</p>
 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myString : <span class="built_in">String</span> = <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在swift中变量主要有Int，Float，Double，String，Bool；当然还有其他的一些基本类型，但是我们主要就是用这些，不知道大家发现了没有，这些和我们在OC中的类型略有区别，他们都是首字母大写的</p>
</li>
<li><p>swift中引进了一个新的类型就是元组Tuples,大家可以看到元组有些类似数组，但是有不同于数组，并且和字典也有些许的类似，我觉得可以算作是字典和数组的整合，在元组中我们如果只想取出其中某个值，而其他的我们不在意，那么我们可以用<code>_</code>来代替那个不在意的值</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> registrationRestult = (<span class="literal">true</span>, <span class="string">"好烦"</span>, <span class="string">"男"</span>)</span><br><span class="line">registrationRestult.<span class="number">0</span></span><br><span class="line">registrationRestult.<span class="number">1</span></span><br><span class="line">registrationRestult.<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="built_in">test</span> = (<span class="built_in">test</span>1:<span class="literal">true</span>, <span class="built_in">test</span>2:<span class="string">"好烦"</span>, <span class="built_in">test</span>3:<span class="string">"真的好烦"</span>)</span><br><span class="line"></span><br><span class="line">test.test1</span><br><span class="line">test.test2</span><br><span class="line">test.test3</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> loginResult : (Bool, String) = (<span class="literal">true</span>, <span class="string">"hahaha"</span>)</span><br><span class="line"><span class="built_in">let</span> (isLoginSuccess, _) = loginResult</span><br><span class="line">isLoginSuccess</span><br></pre></td></tr></table></figure>
</li>
<li><p>if语句，在swift中我们不能用真值来直接当做true来判断，我们必须指明一个逻辑的值，要么是一个布尔值，要么就是表达式</p>
</li>
<li>可选型Optionals，就是指或者是一个值，或者是没有值，没有值时为nil，如下，第二行我们并没有初始化，但是打印出来的是nil，当然我们也可以进行初始化如下第三行，我们可以在确定一定有值得情况下，在值后面加<code>!</code>来说明他肯定是有值的，加<code>!</code>也叫作对可选型的解包这就是可选型了</li>
</ol>
<pre><code><span class="comment"><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imOptionalVariable:Int?</span><br><span class="line"></span><br><span class="line">imOptionalVariable</span><br><span class="line"></span><br><span class="line">imOptionalVariable = <span class="number">13</span></span><br></pre></td></tr></table></figure></span>
</code></pre><ol>
<li>Objective-C中nil是一个空指针，二swift中nil所指更加广泛，我们甚至可以赋值Int，Float类型为nil</li>
<li><p>nil聚合运算符，是在可选型进行判断时进行使用的，不过b是需要和a解包后的类型一致的</p>
 <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">a</span> ?? b  =&gt;  <span class="operator">a</span> != nil ? <span class="operator">a</span>! : b</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数组和字典使用<code>[]</code>,以<code>[]</code>中的值来区分到底是字典还是数组，字典的话是一个一个键值对，创建一个空的字典或者是数组使用<code>[类名]()</code>的形式</p>
 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 数组</span><br><span class="line">var shoppingList = ["catfish", "water", "tulips", "blue paint"]</span><br><span class="line">// 字典</span><br><span class="line">var occupations = [</span><br><span class="line"><span class="code">	"Malcolm" : "Captain",</span></span><br><span class="line"><span class="code">	"Kaylee" : "Mechanic"</span></span><br><span class="line">]</span><br><span class="line">// 为字典添加一个键为“Jayne”的值</span><br><span class="line">occupations["Jayne"] = "Public Relations"</span><br><span class="line">// 空字符串类型的数组</span><br><span class="line">let emptyArray = [<span class="link_label">String</span>](<span class="link_url"></span>)</span><br><span class="line">// 空字典</span><br><span class="line">let emptyDictionary = [<span class="link_label">String:Float</span>](<span class="link_url"></span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>if和for-in</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let individualScores = [75, 43, 103, 87, 12]</span><br><span class="line"><span class="keyword">var</span> teamScore = 0</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">score</span> <span class="keyword">in</span> individualScores &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">score</span> &gt; 50 &#123;</span><br><span class="line">		teamScore += 3</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		teamScore += 1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">print</span>(teamScore)</span><br></pre></td></tr></table></figure>
</li>
<li><p>区间运算符</p>
<blockquote>
<p>闭区间[a,b] =&gt; a…b</p>
<p>前闭后开区间[a,b) =&gt; a..&lt;b</p>
</blockquote>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/swift/">swift</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/11/04/Runtime/" title="Runtime" itemprop="url">Runtime</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://yoursite.com/about" title="Vodka" target="_blank" itemprop="author">Vodka</a>
		
  <p class="article-time">
    <time datetime="2014-11-04T10:01:12.000Z" itemprop="datePublished"> 发表于 2014-11-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="简介"><strong>简介</strong></h4><ol>
<li>Runtime简称运行时。OC就是运行时机制，也就是在运行的时候的机制，其中最主要的是消息机制</li>
<li>对于C语言，<code>函数的调用在变异的时候会决定调用哪些函数</code>。</li>
<li>对于OC的函数，属于<code>动态调用</code>。在编译的时候你并不知道真正要调用的是哪个函数，只有在真正运行的时候才根据函数的名称找到对应的函数来调用。</li>
<li>事实证明：<ul>
<li>在编译阶段，OC可以调用<code>任何函数</code>，即使这个函数并没有实现，只要声明就不会报错</li>
<li>在编译阶段，C语言调用<code>为实现的函数</code>就是报错，原因正如第二条所说</li>
</ul>
</li>
</ol>
<h4 id="Runtime术语"><strong>Runtime术语</strong></h4><h5 id="SEL"><em>SEL</em></h5><ul>
<li><p>它是selector在Objc中的表示类型（Swiftt中是Selector类）。<code>selector</code>是方法选择器，可以理解为区分方法的ID，数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其本身就是映射到方法的C字符串，可以用Objc编译器命令<code>@selector()</code>或者Runtime中的<code>sel_registerName</code>函数来获得一个SEL类型的方法选择器</p>
</li>
<li>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同依然会具有相同的方法选择器，于是Objc中方法命名有时会带上参数类型</li>
</ul>
<h5 id="id"><em>id</em></h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>那么objc_object是个什么鬼呢：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_objet</span> </span>&#123;Class isa;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>objc_object结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类<br><code>注意：</code>isa指针不总是指向实例对象多数的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类，因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类</p>
</li>
</ul>
<h5 id="Class"><em>Class</em></h5><ul>
<li><p>其实Class是个指向objc_class结构体的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>objc_class就是我们摸到的瓜：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">   Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">    </span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">   Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">   <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">   <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">   <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">   <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">   <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">   <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">   <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到运行时一个类还关联了他的超类指针，类名，成员变量，方法，缓存，附属协议</p>
</li>
<li>在Objective-C 2.0的头文件虽然没暴露出objc_class结构体更详细的设计，我们依然可以从Objective-C 1.0的定义中窥探出一点东西：</li>
<li>在objc_class结构体中：ivars是objc_ivar_list指针；methodLists是指向objc_method_list指针的指针。也就会说动态修改*methodlists的值来添加成员方法，这也是Category的实现原理</li>
<li><p>其中objc_ivar_list和objc_method_list分别是成员变量列表和方法列表：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line">   <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">   <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">   <span class="comment">/* variable length structure */</span></span><br><span class="line">   <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">   <span class="keyword">struct</span> objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">   <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">   <span class="comment">/* variable length structure */</span></span><br><span class="line">   <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以理解为objc_ivar_list结构体存储着objc_ivar数组列表，而objc_ivar结构体存储了类的单个成员变量的信息；同理objc_method_list结构体存储着objc_method数组列表，而objc_method结构体存储了类的某个方法信息</p>
</li>
<li>objc_cache：缓存，它在objc_class的作用很重要，随后会有讲到</li>
<li>objc_class中也有一个isa对象，这是因为一个Objc类本身同事也是一个对象，为了处理类和对象的关系，Runtime库创建了一种叫做元类（Meta Class）的东西，类对象所属类型就叫做元类，它用来表达类对象本身所具备的元数据。类方法就定义与此。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似<code>[NSObject alloc]</code>的消息时，事实上是把这个消息给了一个类对象（Class Object），这个类对象必须是一个元类的实例，而这个元类同事也是一个根元类（root mate class）的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。</li>
</ul>
<h5 id="Method"><em>Method</em></h5><ul>
<li><p>Method是一种代表类中的某个方法的类型</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>而objc_method在上面的方法列表中提到过，他存储了方法名，方法类型和方法实现</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> </span>&#123;</span><br><span class="line">   SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">   char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">   IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法名类型method_types是个char指针，其实存储着方法的参数类型和返回值类型</p>
</li>
<li>method_imp指向了方法的实现，本质上是一个函数指针</li>
</ul>
<h5 id="Ivar"><em>Ivar</em></h5><ul>
<li><p>Ivar是一种代表类中实例变量的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br></pre></td></tr></table></figure>
</li>
<li><p>objc_ivar在上面成员变量雷彪中也提到过：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">   <span class="keyword">char</span> *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">   <span class="keyword">char</span> *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">   <span class="keyword">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">   <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="IMP"><em>IMP</em></h5><ul>
<li><p>IMP在objc.h中的定义是：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id (*IMP)(id, SEL, <span class="keyword">...</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>他就是一个函数指针，这是由编译器生成的。当你发起一个Objc消息之后，最终会执行的那段代码，就是有这个指针制定的。而IMP这个函数指针就指向了这个方法的实现。既然得到了执行某个实例方法的入口，就可以绕开消息传递阶段，直接执行方法</p>
</li>
<li>你会发现IMP指向的方法objc_msgSend函数相同，参数都包含id和SEL类型，每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的SEL对应的方法实现肯定是为一的，通过一组id和SEL参数就能确定为一的方法实现地址</li>
</ul>
<h5 id="Cache"><em>Cache</em></h5><ul>
<li><p>在runtime.h中Cache的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache；</span><br></pre></td></tr></table></figure>
</li>
<li><p>之前objc_class结构体有一个<code>struct objc_cache *cache</code>，他到底是缓存什么的呢，先看看实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">   Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cache为方法调用的性能进行优化，通俗的讲，每当实例对象接受到一个消息时，它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法，因为效率太低了，而是优先在Cache中查找。Runtime系统会把被调动的方法存到Cache中（理论上讲，一个方法如果被调用，那么他有可能今后还会调用），下次查找的时候效率更高。</p>
</li>
</ul>
<h5 id="Property"><em>Property</em></h5><ul>
<li><p>它是一个指向objc_property结构体的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *Property;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;<span class="comment">// 这个更常用一点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过class_copyPropertyList和protocol_copyPropertyList方法来获取类和协议中的属性：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t *<span class="function"><span class="title">class_copyPropertyList</span><span class="params">(Class cls, unsigned int *outCount)</span></span></span><br><span class="line">objc_property_t *<span class="function"><span class="title">protocol_copyPropertyList</span><span class="params">(Protocol *proto, unsigned int *outCount)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回类型为指向指针的指针，因为属性列表是个数组，每个元素内容都是一个objc_property_t指针，而这两个函数返回值都指向这个指针。</p>
</li>
<li><p>例如：声明一个类：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">Lender :</span> NSObject &#123;</span><br><span class="line">   <span class="typename">float</span> alone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@property</span> <span class="typename">float</span> alone;</span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以用下面的代码获取属性列表：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">id</span> LenderClass = objc_getClass(<span class="string">"Lender"</span>);</span><br><span class="line"><span class="title">unsigned</span> int outCount;</span><br><span class="line"><span class="title">objc_property_t</span> *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以用property_getName函数来查找属性名称：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *<span class="function"><span class="title">property_getName</span><span class="params">(objc_property_t property)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以用class_getProperty和protocol_getProperty通过给出的名称来在类核协议中获取属性的引用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">objc_property_t protocol_getProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty)</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以用property_getAttributes函数来发掘属性的名称和@encode类型字符串：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *<span class="function"><span class="title">property_getAttributes</span><span class="params">(objc_property_t property)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上面代码放在一起，就能从一个类获取他的属性了：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">id</span> LenderClass = objc_getClass(<span class="string">"Lender"</span>);</span><br><span class="line">unsigned int outCount, i;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">   objc_property_t <span class="keyword">property</span> = properties[i];</span><br><span class="line">   fprintf(stdout, <span class="string">"%s %s\n"</span>, property_getName(<span class="keyword">property</span>), property_getAttributes(<span class="keyword">property</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对比下class_copyIvarList函数，使用class_copyPropertyList函数只能获取类的属性，而不包括成员变量。但此时获取的属性名不带下划线的。</p>
</li>
</ul>
<h4 id="Runtime作用"><strong>Runtime作用</strong></h4><h5 id="发送消息"><em>发送消息</em></h5><ul>
<li>方法调用的本质，就是让对象发送消息</li>
<li>objc_msgSend只有对象才能发消息，所以以objc开头</li>
<li>使用消息机制前提，必须导入<code>#import &lt;objc/runtime.h&gt;</code></li>
<li>由于Xcode6之后苹果不想我们随便使用runtime，没有参数提示，可进行如下设置<code>build setting -&gt; 搜索msg -&gt; YES改为NO</code>，意思就是不让Xcode严格监听runtime方法</li>
<li>简单使用：</li>
<li>clang -rewrite-objc main.m查看最终生成代码<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Person</span> *person = [[<span class="variable">Person</span> alloc] init];</span><br><span class="line">person.name = @<span class="string">"Kevin"</span>;</span><br><span class="line">person.age = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="pp">----&gt;</span><br><span class="line"></span><br><span class="line">Person *person = objc_msgSend<span class="params">(<span class="function_name">objc_msgSend</span>(<span class="function_name">objc_getClass</span>(<span class="string">"Person"</span>), <span class="function_name">sel_registerName</span>(<span class="string">"alloc"</span>)), <span class="function_name">sel_registerName</span>(<span class="string">"init"</span>))</span>;</span><br><span class="line">objc_msgSend<span class="params">((id)</span>person, sel_registerName<span class="params">(<span class="string">"setName:"</span>)</span>, <span class="params">(<span class="variable">NSString</span> *)</span>&amp;__NSConstantStringImpl__var_folders_jt_pt19d0r12xj4j798kb2sj4vh0000gn_T_main_befc80_mi_0);</span><br><span class="line">objc_msgSend<span class="params">((id)</span>person, sel_registerName<span class="params">(<span class="string">"setAge:"</span>)</span>, 24);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="方法调用流程"><em>方法调用流程</em></h5><ul>
<li>首先对象方法放在类对象方法列表，类方法放在元类方法列表</li>
<li>通过isa指针去对应的类中查找</li>
<li>注册方法编号</li>
<li>根据方法编号去查找对应方法</li>
<li>找到的只是最终函数的实现地址，根据地址去方法区调用对应函数</li>
</ul>
<h5 id="交换方法"><em>交换方法</em></h5><ul>
<li>开发使用场景：系统自带的方法功能不够，给系统自带的方法扩展一些功能，并保持原有功能</li>
<li>方法一：继承系统的类，重写方法</li>
<li>方法二：使用runtime，交换方法</li>
<li><p>下面介绍第二种方法:</p>
<ul>
<li>给系统的方法添加分类</li>
<li>自己实现一个带有扩展功能的方法</li>
<li>交换方法<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">  <span class="comment">// 获取方法</span></span><br><span class="line">  Method myMethod = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(ly_imageNamed:));</span><br><span class="line">  Method sysMethod = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageNamed:));</span><br><span class="line">      </span><br><span class="line">  method_exchangeImplementations(sysMethod, myMethod);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">UIImage</span> *)ly_imageNamed:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">  <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> ly_imageNamed:name];</span><br><span class="line">  <span class="keyword">if</span> (image) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"图片加载成功"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"图片加载失败"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用的时候我们仅仅需要调用系统的方法就可以使用我们自己的方法，而且不需要导入分类，</p>
</li>
</ul>
<h5 id="动态添加方法"><em>动态添加方法</em></h5><ul>
<li>开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某给类添加方法解决</li>
<li>你可以动态实现一个方法实现。如果我们使用关键字<code>@dynamic</code>在类的实现文件中修饰一个属性，表明我们会为这个属性动态听存取方法，编译器不再默认为我们生成这个属性的setter和getter方法，需要我们自己提供。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">dynamic</span> propertyName</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>这时，我们可以分别通过重载<code>resolveInstanceMethod</code>和<code>resolveClassMethod</code>方法添加实例方法和类方法实现。</li>
<li><p>当Runtime系统在Cache和类的方法列表（包括父类）中找不到要执行的方法是，Runtime会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>来给我们一次动态添加方法的机会。我么需要用<code>class_addMethod</code>函数来完成想特定类添加特定方法实现的操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> work(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 什么时候调用？只要一个对象调用了一个为实现的方法就会调用这个方法，进行处理</span></span><br><span class="line"><span class="comment">// 作用：动态添加方法，处理为实现方法</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (sel == NSSelectorFromString(<span class="string">@"work"</span>)) &#123;</span><br><span class="line">       <span class="comment">// cls 给那个类添加方法</span></span><br><span class="line">       <span class="comment">// name 添加哪个方法</span></span><br><span class="line">       <span class="comment">// imp 方法的实现 =&gt; 函数 =&gt; 函数入口 =&gt; 函数名</span></span><br><span class="line">       <span class="comment">// type  方法类型</span></span><br><span class="line">       class_addMethod(<span class="keyword">self</span>, sel, (IMP)work, <span class="string">"v@:"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法类型即上例中<code>v@:</code>,详见<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">Type Encodings</a></p>
</li>
<li>我们可以观察到我们自己写的work方法里面有两个参数：self和_cmd，这两个参数是任何方法都有的两个隐式参数，系统自动传入相应的值。<code>self</code>是指接受消息的对象，<code>_cmd</code>是指当前方法的方法编号</li>
</ul>
<h5 id="给分类添加属性"><em>给分类添加属性</em></h5><ul>
<li>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类内存空间</li>
<li>应用场景：给系统的类添加一个属性：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="comment">// ojbect 给那个对象添加属性</span></span><br><span class="line">    <span class="comment">// key 属性名</span></span><br><span class="line">    <span class="comment">// value 属性值</span></span><br><span class="line">    <span class="comment">// policy 保存的策略</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="string">"name"</span>, name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="string">"name"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="字典转模型"><em>字典转模型</em></h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"NSObject+Model.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/message.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Model</span>)</span></span><br><span class="line">+ (instancetype)modelWithDict:(<span class="built_in">NSDictionary</span> *)dict &#123;</span><br><span class="line">    <span class="keyword">id</span> obj = [[<span class="keyword">self</span> alloc]init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 根据模型中的属性，去字典中查找相应的value给模型赋值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1.1 获取成员变量</span></span><br><span class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 1.2 获取成员变量名称</span></span><br><span class="line">        Ivar ivar = ivarList[i];</span><br><span class="line">        <span class="built_in">NSString</span> *ivarName = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        <span class="comment">// 1.3 裁剪字符串中的_</span></span><br><span class="line">        <span class="built_in">NSString</span> *key = [ivarName substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取成员变量类型</span></span><br><span class="line">        <span class="built_in">NSString</span> *ivarType = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</span><br><span class="line">        <span class="comment">// 获取到的ivarType 为 @\"User\" -&gt; 进行如下替换</span></span><br><span class="line">        ivarType = [ivarType stringByReplacingOccurrencesOfString:<span class="string">@"\""</span> withString:<span class="string">@""</span>];</span><br><span class="line">        ivarType = [ivarType stringByReplacingOccurrencesOfString:<span class="string">@"@"</span> withString:<span class="string">@""</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 字典中取值</span></span><br><span class="line">        <span class="keyword">id</span> value = dict[key];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> class]] &amp;&amp; ![ivarType hasPrefix:<span class="string">@"NS"</span>]) &#123;</span><br><span class="line">            Class cls = NSClassFromString(ivarType);</span><br><span class="line">            value = [cls modelWithDict:value];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            [obj setValue:value forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/runtime/">runtime</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/XML-JSON/" title="XML&amp;JSON">XML&amp;JSON<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/CocoaPods/" title="CocoaPods">CocoaPods<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/类的启动过程/" title="类的启动过程">类的启动过程<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/手写Button设置/" title="手写Button设置">手写Button设置<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/autoresizingMask/" title="autoresizingMask">autoresizingMask<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/swift/" title="swift">swift<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/iOS框架/" title="iOS框架">iOS框架<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/沙盒/" title="沙盒">沙盒<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/MD5加密/" title="MD5加密">MD5加密<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Quartz2D使用/" title="Quartz2D使用">Quartz2D使用<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/viewController生命周期/" title="viewController生命周期">viewController生命周期<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Pch文件/" title=".Pch文件">.Pch文件<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Xcode插件删除/" title="Xcode插件删除">Xcode插件删除<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/面向对象思想/" title="面向对象思想">面向对象思想<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ToolBar/" title="ToolBar">ToolBar<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NavController-UIButtonItem/" title="NavController-UIButtonItem">NavController-UIButtonItem<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UIButton/" title="UIButton">UIButton<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UIApplication/" title="UIApplication">UIApplication<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SVN/" title="SVN">SVN<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/runtime/" title="runtime">runtime<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.code4app.com" target="_blank" title="第三方源码">Code4APP</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.cocoachina.com" target="_blank" title="CocoaChina">CocoaChina</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.stackoverflow.com" target="_blank" title="StackOverFlow">StackOverFlow</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Vodka. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/LeeLovCY" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="http://yoursite.com/about" target="_blank" title="Vodka">Vodka</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
